package com.simpson.josh.lost;import android.util.Log;import java.util.*;/** * Created by Josh on 04/02/2015. */public class Dijkstra {    DiGraph dg;    ArrayList<Node> nodeList;    ArrayList<Edge> edgeList;    Set<Node> visitedNodes;    Set<Node> unVisitedNodes;    Map<Node, Node> predecessors;    Map<Node, Integer> distance;    public Dijkstra(DiGraph graph) {        this.nodeList = new ArrayList<Node>(DiGraph.nodes.values());        this.edgeList = new ArrayList<Edge>(DiGraph.edges);        this.dg = graph;    }    public void execute(Node sourceNode) {        //Set up all those empty objects        setup();        //Get ready to rumble        distance.put(sourceNode, 0);        //Obviously we're starting at the source node        unVisitedNodes.add(sourceNode);        //For every unvisited node        while (unVisitedNodes.size() > 0) {            // Visit the closest one            Node node = getMinimum(unVisitedNodes);            visitedNodes.add(node);            unVisitedNodes.remove(node);            findMinDistances(node);        }    }    public void setup() {        visitedNodes = new HashSet<Node>();        unVisitedNodes = new HashSet<Node>();        distance = new HashMap<Node, Integer>();        predecessors = new HashMap<Node, Node>();    }    private Node getMinimum(Set<Node> nodes) {        Node min = null;        for (Node n : nodes) {            if (min == null) {                // Base case                min = n;            } else {                // Loop through find shortest distance path                if (getShortestDistance(n) < getShortestDistance(min)) {                    min = n;                }            }        }        return min;    }    public List<Node> getNeighbours(Node sourceNode) {        List<Node> neighbours = new ArrayList<Node>(dg.getAdjacency(sourceNode).keySet());        // Go through edgelist,remove any visited nodes        if (neighbours.size() == 0) {            Log.d("Neighbours is empty", "We messed up");        }        for( Node n : neighbours)        {            if(visitedNodes.contains(n))            {                // Make sure we don't pass through any nodes we've already visited                neighbours.remove(n);            }        }        return neighbours;    }    public boolean isVisited(Node node) {        return visitedNodes.contains(node);    }    public int getDistance(Node sourceNode, Node targetNode) {        int weight = 1;        for (Edge e : edgeList) {            // Need to go back to this for efficiency - breaking the loop when it finds a result            // stops the wasting time continuing the loop for now            if (e.startNode == sourceNode && e.endNode == targetNode) {                weight = e.weight;                break;            }        }        return weight;    }    public int getShortestDistance(Node destinationNode) {        Integer d = distance.get(destinationNode);        if (d == null) {            return 9999;        } else {            return d;        }    }    public void findMinDistances(Node node) {        List<Node> adjacentNodes = getNeighbours(node);        Log.d("LOL", "" + adjacentNodes.size());        for (Node target : adjacentNodes) {            if (getShortestDistance(target) > getShortestDistance(node) + getDistance(node, target)) {                distance.put(target, getShortestDistance(node) + getDistance(node, target));                predecessors.put(target, node);                unVisitedNodes.add(target);            }        }    }    public LinkedList<Node> getPath(Node target) {        LinkedList<Node> path = new LinkedList<Node>();        Node step = target;        // check if a path exists        if (predecessors.get(step) == null) {            return path;        }        path.add(step);        while (predecessors.get(step) != null) {            step = predecessors.get(step);            path.add(step);        }        // Put it into the correct order        Collections.reverse(path);        return path;    }}